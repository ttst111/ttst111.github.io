<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[每天一道python练习11]]></title>
      <url>/2017/09/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93python%E7%BB%83%E4%B9%A011/</url>
      <content type="html"><![CDATA[<h4>题目:输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回.</h4>

<p><b>思路:利用二叉树遍历的规则进行重组</b></p>
<p><b>code:</b></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="keyword">if</span> (len(pre) == <span class="number">0</span>) <span class="keyword">or</span> (len(tin) == <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"></div><div class="line">        rootValue = pre[<span class="number">0</span>]</div><div class="line">        root = TreeNode(rootValue)</div><div class="line">        <span class="keyword">if</span> len(pre)==<span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> root</div><div class="line">        rootTinIndex = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tin)):</div><div class="line">            <span class="keyword">if</span> tin[i] == rootValue:</div><div class="line">                rootTinIndex = i</div><div class="line">        preStart = <span class="number">1</span></div><div class="line">        preEnd = rootTinIndex+<span class="number">1</span></div><div class="line">        tinStart = <span class="number">0</span></div><div class="line">        tinEnd = rootTinIndex</div><div class="line">        <span class="keyword">if</span> rootTinIndex &gt; <span class="number">0</span>:</div><div class="line">            root.left = self.reConstructBinaryTree(pre[preStart:preEnd], tin[tinStart:tinEnd])</div><div class="line">        <span class="keyword">if</span> rootTinIndex &lt; len(pre):</div><div class="line">            root.right = self.reConstructBinaryTree(pre[preEnd:], tin[tinEnd+<span class="number">1</span>:])</div><div class="line">        <span class="keyword">return</span> root</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 二叉树遍历 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每天一道python练习10]]></title>
      <url>/2017/09/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93python%E7%BB%83%E4%B9%A010/</url>
      <content type="html"><![CDATA[<p></p><h4>题目:输入一个链表，从尾到头打印链表每个节点的值。</h4><br><p></p>
<p><b>思路:append函数移动，reserve函数调序</b></p>
<p><b>code:<b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">	Arr=[]</div><div class="line">	Head=listNode</div><div class="line">	<span class="keyword">while</span> head:</div><div class="line">	    Arr.append(head.val)</div><div class="line">	    head=head.next</div><div class="line"></div><div class="line">	Arr.reverse()</div><div class="line">	<span class="keyword">return</span> Arr</div></pre></td></tr></table></figure></b></b></p>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 链表 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每天一道python练习09]]></title>
      <url>/2017/08/31/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93python%E7%BB%83%E4%B9%A009/</url>
      <content type="html"><![CDATA[<p><b>题目:</b>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><b>思路:</b>直接调用python的replace函数,或者使用序列切片方式。</p>
<p><b>code1:<b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># s 源字符串</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="keyword">return</span> s.replace(<span class="string">" "</span>,<span class="string">"%20"</span>)</div></pre></td></tr></table></figure></b></b></p>
<p><b>code2:</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># s 源字符串</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">            <span class="keyword">while</span> s.find(<span class="string">" "</span>,<span class="number">0</span>,len(s))&gt;=<span class="number">0</span>:</div><div class="line">                a=s.find(<span class="string">" "</span>,<span class="number">0</span>,len(s))</div><div class="line">                s=s[<span class="number">0</span>:a]+<span class="string">"%20"</span>+s[a+<span class="number">1</span>:len(s)]</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> s</div></pre></td></tr></table></figure></p>
<p><b>注释：</b><br>replace()方法语法：<br>str.replace(old, new[, max])</p>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 字符串替换 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每天一道python练习08]]></title>
      <url>/2017/08/31/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93python%E7%BB%83%E4%B9%A008/</url>
      <content type="html"><![CDATA[<p><b>题目:</b>在一个二位数组中，每一行按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><b>分析:</b>例如数组:</p><p>1 4 5</p><p>2 6 8</p><p>4 8 10</p><p>6 9 12</p> 从二维数组的右上角开始分析，如果要查找的数大于该数字，则去掉这一行；如果要查找的数字小于该数字，则去掉这一列；如果等于查找结束。以此类推，如果要查找的数不再数组的右上角，则去掉一行或者一列，逐渐缩小范围，直到找到为止，或者找不到返回为空.例如查找9，9&gt;5删除第一行；9&gt;8,删除第二行；9小于10，删除第3列；9&gt;6，删除第三行；最后9=9,查找结束.<p></p>
<p><b>code:</b></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># array 二维列表</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        m= len(array) - <span class="number">1</span></div><div class="line">        i= <span class="number">0</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> m &gt;= <span class="number">0</span> <span class="keyword">and</span> i&lt; len(array[<span class="number">0</span>]):</div><div class="line">            <span class="keyword">if</span> array[m][i]&gt;target:</div><div class="line">                m-=<span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> array[m][i]&lt;target:</div><div class="line">                i+=<span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 二维数组查找 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见的防火墙有的类型]]></title>
      <url>/2017/08/21/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>今天做阿里2017安全工程师笔试模拟的时候看到这个问题，常见的网络防火墙有哪些类型及他们的优缺点？大公司会选择那种防火墙。（大概是这样)<br>所以今天就大概的介绍一下防火墙的基本类型。</p>
<h4>什么是防火墙</h4><br>首先什么是防火墙，防火墙是指由软件和硬件组合而成，用于隔离内网和外网、公用网络和专业网络之间的一道安全屏障。防火墙可以保护内网免<br>受非法用户的入侵和绝大多数的网络攻击，防火墙主要由匹配规则、验证工具、包过滤以及应用网关这4个部分组合而成，所有从内外网流出的数据<br>都要经过防火墙的检测，只有符合安全规则的数据才能从防火墙通过，<br><br><h4>包过滤防火墙</h4><br>首先是最基本的包过滤防火墙，包过滤防火墙通过查看数据包的包头信息与特征库里的信息进行比对，如果没有比对到特征码，则认为数据包是安全的<br>，通过数据包；否则就丢弃该数据包。<br><br>包过滤在IP层进行实现，通过检查数据包的源IP地址、目标IP地址、源端口号、目标端口号、网络协议的类型等信息来进行判断数据包的安全性包过滤<br>也可以对服务类型进行过滤，可以知道特定的服务进行过滤，由于绝大多数的服务都在TCP/UDP端口上，因此只需要对特定的端口数据包进行丢弃即可.<br>包过滤一般通过一台路由器或主机进行过滤，列入在常见的Cisco路由设备上，可以通过配置ACL（访问控制列表),来对数据包进行控制，可以进行如下<br>的访问控制:<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int s0   <span class="comment">#进入路由器的s0端口</span></div><div class="line"></div><div class="line">ip access-gropu <span class="number">104</span> <span class="keyword">in</span>    <span class="comment">#建立访问控制列表104</span></div><div class="line"></div><div class="line">access-list <span class="number">104</span> deny host  <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>  <span class="comment">#禁止192.168.1.1的数据包通过</span></div><div class="line"></div><div class="line">access-list <span class="number">104</span> permit any <span class="comment">#允许与其他人以计算机进行通信</span></div><div class="line"></div><div class="line">access-list <span class="number">104</span> deny tcp any host <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> eq www <span class="comment">#禁止所有通过TCP连接访问192.168.1.1的www服务的数据包</span></div><div class="line"></div><div class="line">access-list <span class="number">104</span> permit tcp <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.255</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.0</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.255</span> establish <span class="comment">#如果连接建立，允许192.168.1.0网段的计算机访问192.168.2.0网段的计算机</span></div></pre></td></tr></table></figure><br><br>从以上可以看出包过滤防火墙只关注IP包头的信息，而不会去解封数据字段，所以可以得出以下优缺点：<br><br><b>优点:</b><br>-由于只对数据的包头进行检查、因此比较容易实现，适合小型、不太复杂的网络站点。<br>-应为过滤路由器主要工作在IP层，因此对数据包的处理速度比代理型服务器快.<br>-对于用户而言过滤路由器提供了一种透明服务，用户不需要配置，也被称为透明网关.<br>-价格比较便宜<br><br><b>缺点:</b><br>-显而易见由于是透明服务，因此包过滤网关不支持身份认证.<br>-特征库只能匹配已近存在的攻击，对于新型网络攻击无法解决.<br>-如果外网用户被允许访问内网的主机，那么他基本能访问所有主机.<br>-太依赖单一的部件来保护系统，列入匹配库失效，那么一切保护荡然无存.<br>-只能阻止外部IP伪装内部IP的欺骗，无法阻止外部IP伪装外部IP，也不能防止DNS欺骗.<br><br><br><h4>应用代理(网关)防火墙</h4><br>代理型防火墙包括了OSI七层的应用层，而且主要在应用层实现。应用代理起到一个中间人的作用,数据包不直接送服务器而是先流进处于浏览器和服务器之间的代理<br>，有代理服务器将信息传递到服务器端，当接收到服务器端的响应后，再由代理服务器，返回信息到浏览器。代理服务器也可以用于页面的缓存，代理服务器从互联<br>网上下载特定的页面前，先从缓存器中取出页面。内外网之间不存在直接连接.<br><br>由于应用代理防火墙主要在应用层实现，因此可以对网络上一层的数据包进行身份验证，使符合安全故则的通过，其余的丢弃。它允许通过的数据包由网关复制并传<br>递，防止在受信任服务器和客户机与不受信任的主机间直接建立联系。应用代理防火墙还可以起到隐藏内网的结构的作用，内网主机只需要将服务的IP地址指向代理<br>主机，就可以访问网络资源<br><br><b>优点</b><br>-应用代理提供身份认证，用户和密码的认证.<br>-内容过滤， 如上面我们讲到的Unicode攻击，应用代理（网关）防火墙能发现这种攻击，并对攻击进行阻断。此外，还有常见的过滤80端口的Java Applet、JavaScript、<br>ActiveX、电子邮件的MIME类型，还有Subject、To、From等等。<br>-由于突破了OSI的四层，因此可以提供详细的日志记录功能，可以记录应用层的一些相关命令。<br><br><b>缺点:</b><br>-速度慢，由于所有的连接都需要代理服务器的分析、转换、转发，所以速度较慢.<br>-一个明显的弊端就是，醒的网络协议和应用系统都需要新的应用代理.<br><br><h4>状态检测防火墙</h4><br>状态检测防火墙在网络层有一个检测引擎截获数据包并抽取与应用层状态有关的信息，通过这个作为依据是连接通过还是拒绝.状态检测技术最适合提供对UDP协议的有限支持。<br>它将所有通过防火墙的UDP分组均视为一个虚连接，当反向应答分组送达时，就认为一个虚拟连接已经建立。状态检测防火墙克服了包过滤防火墙和应用代理服务器的局限性，<br>不仅仅检测“to”和“from”的地址，而且不要求每个访问的应用都有代理。<br><br>这是第三代防火墙技术，能对网络通信的各层实行检测。同包过滤技术一样，它能够检测通过IP地址、端口号以及TCP标记，过滤进出的数据包。它允许受信任的客户机和不受信任的主机建立直接连接，不依靠<br>与应用层有关的代理，而是依靠某种算法来识别进出的应用层数据，这些算法通过己知合法数据包的模式来比较进出数据包，这样从理论上就能比应用级代理在过滤数据包上更有效。状态监视器的监视模块支持多种协议和应用程序，可方便地实现应用和服务的扩充。此外，它还可监测RPC和UDP端口信息，而包过滤和代理都不支持此类端口。这样，通过对各层进行监测，状态监视器实现网络安全的目的。目前，多使用状态监测防火墙，它对用户透明，在OSI最高层上加密数据，而无需修改客户端程序，也无需对每个需在防火墙上运行的服务额外增加一个代理。<br><br><b>优点:</b><br>-安全性高<br>状态检测防火墙工作在数据链路层和网络层之间，它从这里截取数据包，因为数据链路层是网卡工作的真正位置，网络层是协议栈的第一层，这样防火墙确保了截取和检查所有通过网络的原始数据包。防火墙截取到数据包就处理它们，首先根据安全策略从数据包中提取有用信息，保存在内存中；然后将相关信息组合起来，进行一些逻辑或数学运算，获得相应的结论，进行相应的操作，如允许数据包通过、拒绝数据包、认证连接、加密数据等。状态检测防火墙虽然工作在协议栈较低层，但它检测所有应用层的数据包，从中提取有用信息，如IP地址、端口号、数据内容等，这样安全性得到很大提高。<br><br>-高性能<br>状态检测防火墙工作在协议栈的较低层，通过防火墙的所有的数据包都在低层处理，而不需要协议栈的上层处理任何数据包，这样减少了高层协议头的开销，执行效率提高很多；另外在这种防火墙中一旦一个连接建立起来，就不用再对这个连接做更多工作，系统可以去处理别的连接，执行效率明显提高。<br><br>-可扩展性强<br>状态检测防火墙不像应用网关式防火墙那样，每一个应用对应一个服务程序，这样所能提供的服务是有限的，而且当增加一个新的服务时，必须为新的服务开发相应的服务程序，这样系统的可扩展性降低。状态检测防火墙不区分每个具体的应用，只是根据从数据包中提取出的信息、对应的安全策略及过滤规则处理数据包，当有一个新的应用时，它能动态产生新的应用的新的规则，而不用另外写代码，所以具有很好的伸缩性和扩展性。<br><br>-便于配置，应用范围广<br>状态检测防火墙不仅支持基于TCP的应用，而且支持基于无连接协议的应用，如RPC、基于UDP的应用(DNS 、WAIS、 Archie等)等。对于无连接的协议，连接请求和应答没有区别，包过滤防火墙和应用网关对此类应用要么不支持，要么开放一个大范围的UDP端口，这样暴露了内部网，降低了安全性。<br><br>状态检测防火墙实现了基于UDP应用的安全，通过在UDP通信之上保持一个虚拟连接来实现。防火墙保存通过网关的每一个连接的状态信息，允许穿过防火墙的UDP请求包被记录，当UDP包在相反方向上通过时，依据连接状态表确定该UDP包是否被授权的，若已被授权，则通过，否则拒绝。如果在指定的一段时间内响应数据包没有到达，连接超时，则该连接被阻塞，这样所有的攻击都被阻塞.状态检测防火墙可以控制无效连接的连接时间，避免大量的无效连接占用过多的网络资源，可以很好的降低DOS和DDOS攻击的风险。<br><br>状态检测防火墙也支持RPC，因为对于RPC服务来说，其端口号是不定的，因此简单的跟踪端口号是不能实现该种服务的安全，状态检测防火墙通过动态端口映射图记录端口号，为验证该连接还保存连接状态、程序号等，通过动态端口映射图来实现此类应用的安全。<br><br><b>缺点；</b><br>-数据存在延迟，由于连接建立在复杂的协议分析机制上<br>-不能分析高级协议中的数据.<br>-只检测第三层信息无法识别广告、木马、垃圾邮件等<br>-最大的弊端只能识别已经存在的安全问题、对于新的安全问题无能为力<br><br><h4>最新一代防火墙(第五代防火墙)</h4>

<p>1998年，NAI公司推出了一种自适应代理（Adaptive proxy）技术，并在其产品Gauntlet Firewall for NT中得以实现，给代理类型的防火墙赋予了全新的意义，可以称之为第五代防火墙。</p>
<p>一体化安全网关UTM</p>
<p>UTM统一威胁管理，在防火墙基础上发展起来的，具备防火墙、IPS、防病毒、防垃圾邮件等综合功能的设备。由于同时开启多项功能会大大降低UTM的处理性能，因此主要用于对性能要求不高的中低端领域。在中低端领域，UTM已经出现了代替防火墙的趋势，因为在不开启附加功能的情况下，UTM本身就是一个防火墙，而附加功能又为用户的应用提供了更多选择。在高端应用领域，比如电信、金融等行业，仍然以专用的高性能防火墙、IPS为主流。</p>
<h4>企业级防火墙</h4>

<p>大型企业一般都会选择混合型的防火墙，即集合包过滤、应用代理、状态检测，而且具备IDS、IPS、VPN、放垃圾邮件、支持IPV6和IPV4双协议、支持DDOS防护等功能的大型混合型防火墙。</p>
]]></content>
      
        
        <tags>
            
            <tag> 防火墙 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈内网渗透的思路]]></title>
      <url>/2017/08/21/%E6%B5%85%E8%B0%88%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E6%80%9D%E8%B7%AF/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[每日天一道python练习07]]></title>
      <url>/2017/08/19/%E6%AF%8F%E6%97%A5%E5%A4%A9%E4%B8%80%E9%81%93python%E7%BB%83%E4%B9%A007/</url>
      <content type="html"><![CDATA[<p></p><h4>题目:有一个文件，文件名为output_1981.10.21.txt 。下面使用python： 读取文件名中的日期时间信息，并找出这一天是周几。将文件改名为output_YYYY-MM-DD-W.txt (YYYY:四位的年，MM：两位的月份，DD：两位的日，W：一位的周几，并假设周一为一周第一天)<h4><p></p>
<p><b>分析:主要通过导入正则匹配的库re，利用/d匹配数字（/D匹配非数值类型),通过时间库输出星期几，最后采用sub()函数匹配替换文件名</b></p>
<p>code:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding=utf-8 -*-</span></div><div class="line"><span class="comment"># create Ttstcy</span></div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">有题目:一个文件，文件名为output_1981.10.21.txt 。下面使用python： 读取文件名中的日期</span></div><div class="line"><span class="string">时间信息，并找出这一天是周几。将文件改名为output_YYYY-MM-DD-W.txt (YYYY:四位的年</span></div><div class="line"><span class="string">，MM：两位的月份，DD：两位的日，W：一位的周几，并假设周一为一周第一天)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">'''</span></div><div class="line">filename=<span class="string">"output_1981.10.21.txt"</span></div><div class="line"></div><div class="line">day=re.search(<span class="string">"output_(\d&#123;4&#125;.\d&#123;2&#125;.\d&#123;2&#125;)"</span>,filename)  <span class="comment">#\d匹配数字</span></div><div class="line"></div><div class="line">newDate=day.group(<span class="number">1</span>)     <span class="comment">#获取匹配到的日期</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'%s是周%s'</span> % (newDate,time.strftime(<span class="string">'%w'</span>))</div><div class="line"></div><div class="line"><span class="comment">#分割日期成YY、MM、DD</span></div><div class="line">year=newDate[<span class="number">0</span>:<span class="number">4</span>]</div><div class="line">month=newDate[<span class="number">5</span>:<span class="number">7</span>]</div><div class="line">day=newDate[<span class="number">8</span>:<span class="number">10</span>]</div><div class="line"></div><div class="line">replace=<span class="string">'%s-%s-%s-%s'</span> % (year,month,day,time.strftime(<span class="string">'%w'</span>))</div><div class="line"></div><div class="line">fileName = re.sub(<span class="string">"\d&#123;4&#125;.\d&#123;2&#125;.\d&#123;2&#125;"</span>, replace, filename) <span class="comment">#使用sub()进行替换  </span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'新的文件名为:%s'</span> % fileName</div></pre></td></tr></table></figure></h4></h4>]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql数据库的优化]]></title>
      <url>/2017/08/19/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p><b>一.MySQL的主要适用场景</b></p>
<p>1.Web网站系统</p>
<p>2.日志记录系统</p>
<p>3.数据仓库系统</p>
<p>4.嵌入式系统</p>
<p><b>二.Mysql基本架构图</b><br><img src="/images/mysql.jpg"></p>
<p><b>三.mysql优化</b></p>
<p><b>1.选取最适用的字段属性</b></p>
<p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字<br>段的宽度设得尽可能小。</p>
<p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。<br>同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p>
<p>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOTNULL，这样在将来执行查询的时候，数据库不用去比较NULL值。<br>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型<br>快得多。这样，我们又可以提高数据库的性能。</p>
<p><b>2.使用索引</b></p>
<p>索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提<br>高更为明显。</p>
<p>一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量<br>重复值是很有可能的情况</p>
<p>例如customerinfo中的“province”..字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。我们在创建表的时候可以同时创建合适的索引，也可以使<br>用ALTERTABLE或CREATEINDEX在以后创建索引。此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于<br>一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，然后再使用ALTERTABLE或CREATEINDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，<br>执行过程将会非常慢。</p>
<p><b>3.优化sql查询语句</b></p>
<p>sql语句的优化思路和原则主要提现在以下几个方面：</p>
<ol>
<li><p>优化更需要优化的Query；</p>
</li>
<li><p>定位优化对象的性能瓶颈；</p>
</li>
<li><p>明确的优化目标；</p>
</li>
<li><p>从Explain入手；</p>
</li>
<li><p>多使用profile</p>
</li>
<li><p>永远用小结果集驱动大的结果集；</p>
</li>
<li><p>尽可能在索引中完成排序；</p>
</li>
<li><p>只取出自己需要的Columns；</p>
</li>
<li><p>仅仅使用最有效的过滤条件；</p>
</li>
</ol>
<p>10.尽可能避免复杂的Join和子查询；</p>
<p><b>4.使用事务</b></p>
<p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候<br>是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两<br>个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。<br>要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，<br>COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。<br>事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方法来为用户提供一种安全的访问方式，这样可以保证用户的操作不被其它的用户所干扰。</p>
<p><b>5.多使用外键</b></p>
<p>锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。</p>
<p>例如，外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把customerinfo表中的CustomerID映射到salesinfo表中CustomerID，任何一条没有合法CustomerID的记录都<br>不会被更新或插入到salesinfo中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATETABLEcustomerinfo( CustomerIDINTNOTNULL,PRIMARYKEY(CustomerID))TYPE=INNODB;</div><div class="line"></div><div class="line">CREATETABLEsalesinfo( SalesIDINTNOTNULL,CustomerIDINTNOTNULL,</div><div class="line"></div><div class="line">PRIMARYKEY(CustomerID,SalesID),</div><div class="line"></div><div class="line">FOREIGNKEY(CustomerID)REFERENCEScustomerinfo(CustomerID)ONDELETECASCADE)TYPE=INNODB;</div></pre></td></tr></table></figure></p>
<p>例子中的参数“ONDELETECASCADE”。该参数保证当customerinfo表中的一条客户记录被删除的时候，salesinfo表中所有与该客户相关的记录也会被自动删除。如果要在MySQL中使用外键，一定要<br>记住在创建表的时候将表的类型定义为事务安全表InnoDB类型。该类型不是MySQL表的默认类型。定义的方法是在CREATETABLE语句中加上TYPE=INNODB。</p>
<p><b>6.选取正确的字段属性</b></p>
<p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p>
<p>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOTNULL，这样在将来执行查询的时候，数据库不用去比较NULL值。<br>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p>
<p><b>四.Mysql的Stroge Engine</b></p>
<ol>
<li>MyISAM存储引擎</li>
</ol>
<p>MyISAM存储引擎的表在数据库中，每一个表都被存放为三个以表名命名的物理文件。首先肯定会有任何存储引擎都不可缺少的存放表结构定义信息的.frm文件，另外还有.MYD和.MYI文件，分别存放了表的数据（.MYD）和索引数据（.MYI）。每个表都有且仅有这样三个文件做为MyISAM存储类型的表的存储，也就是说不管这个表有多少个索引，都是存放在同一个.MYI文件中。</p>
<p>MyISAM支持以下三种类型的索引：</p>
<p>1.1 B-Tree索引</p>
<p>B-Tree索引，顾名思义，就是所有的索引节点都按照balancetree的数据结构来存储，所有的索引数据节点都在叶节点。</p>
<p>1.2 R-Tree索引</p>
<p>R-Tree索引的存储方式和b-tree索引有一些区别，主要设计用于为存储空间和多维数据的字段做索引，所以目前的MySQL版本来说，也仅支持geometry类型的字段作索引。</p>
<p>1.3 Full-text索引</p>
<p>Full-text索引就是我们长说的全文索引，他的存储结构也是b-tree。主要是为了解决在我们需要用like查询的低效问题。</p>
<p>2.Innodb 存储引擎</p>
<p>2.1 支持事务安装</p>
<p>2.2 数据多版本读取</p>
<p>2.3 锁定机制的改进</p>
<p>2.4 实现外键</p>
<p> NDBCluster存储引擎</p>
<p>NDB存储引擎也叫NDBCluster存储引擎，主要用于MySQLCluster分布式集群环境，Cluster是MySQL从5.0版本才开始提供的新功能。</p>
<p> Merge存储引擎</p>
<p>MERGE存储引擎，在MySQL用户手册中也提到了，也被大家认识为MRG_MyISAM引擎。Why？因为MERGE存储引擎可以简单的理解为其功能就是实现了对结构相同的MyISAM表，通过一些特殊的包装对外提供一个单一的访问入口，以达到减小应用的复杂度的目的。要创建MERGE表，不仅仅基表的结构要完全一致，包括字段的顺序，基表的索引也必须完全一致。</p>
<p> Memory存储引擎</p>
<p>Memory存储引擎，通过名字就很容易让人知道，他是一个将数据存储在内存中的存储引擎。Memory存储引擎不会将任何数据存放到磁盘上，仅仅存放了一个表结构相关信息的.frm文件在磁盘上面。所以一旦MySQLCrash或者主机Crash之后，Memory的表就只剩下一个结构了。Memory表支持索引，并且同时支持Hash和B－Tree两种格式的索引。由于是存放在内存中，所以Memory都是按照定长的空间来存储数据的，而且不支持BLOB和TEXT类型的字段。Memory存储引擎实现页级锁定。</p>
<p> BDB存储引擎</p>
<p>BDB存储引擎全称为BerkeleyDB存储引擎，和Innodb一样，也不是MySQL自己开发实现的一个存储引擎，而是由SleepycatSoftware所提供，当然，也是开源存储引擎，同样支持事务安全。</p>
<p> FEDERATED存储引擎</p>
<p>FEDERATED存储引擎所实现的功能，和Oracle的DBLINK基本相似，主要用来提供对远程MySQL服务器上面的数据的访问接口。如果我们使用源码编译来安装MySQL，那么必须手工指定启用FEDERATED存储引擎才行，因为MySQL默认是不起用该存储引擎的。</p>
<p> ARCHIVE存储引擎</p>
<p>ARCHIVE存储引擎主要用于通过较小的存储空间来存放过期的很少访问的历史数据。ARCHIVE表不支持索引，通过一个.frm的结构定义文件，一个.ARZ的数据压缩文件还有一个.ARM的meta信息文件。由于其所存放的数据的特殊性，ARCHIVE表不支持删除，修改操</p>
<p>作，仅支持插入和查询操作。锁定机制为行级锁定。</p>
<p> BLACKHOLE存储引擎</p>
<p>BLACKHOLE存储引擎是一个非常有意思的存储引擎，功能恰如其名，就是一个“黑洞”。就像我们unix系统下面的“/dev/null”设备一样，不管我们写入任何信息，都是有去无回。</p>
<p> CSV存储引擎</p>
<p>CSV存储引擎实际上操作的就是一个标准的CSV文件，他不支持索引。起主要用途就是大家有些时候可能会需要通过数据库中的数据导出成一份报表文件，而CSV文件是很多软件都支持的一种较为标准的格式，所以我们可以通过先在数据库中建立一张CVS表，然后将生成的报表信息插入到该表，即可得到一份CSV报表文件了。</p>
]]></content>
      
        
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每天一道python练习06]]></title>
      <url>/2017/08/18/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93python%E7%BB%83%E4%B9%A006/</url>
      <content type="html"><![CDATA[<h3>题目：建立一个简单的TCP客户端和服务器.</h3>

<h4>1.采用socket模块建立</h4>

<p><b>Tcp服务器代码:</b></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># create Ttstcy</span></div><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">一个简单的tcp服务器</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">'''</span></div><div class="line">Host=<span class="string">'127.0.0.1'</span>   </div><div class="line">Port=<span class="number">56478</span></div><div class="line">Buffer=<span class="number">1024</span></div><div class="line">add=(Host,Port)</div><div class="line"></div><div class="line">tcpSocket=socket(AF_INET,SOCK_STREAM) <span class="comment">#建立socket套接字</span></div><div class="line">tcpSocket.bind(add)                   <span class="comment">#绑定地址</span></div><div class="line">tcpSocket.listen(<span class="number">5</span>)                   <span class="comment">#接受最大连接数</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">	print(<span class="string">'waiting for connection......'</span>)</div><div class="line">	tcpSocket,add=tcpSocket.accept()       <span class="comment">#接收客户端连接</span></div><div class="line">	print(<span class="string">'connection from:'</span> , add)</div><div class="line"></div><div class="line">	<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">		data=tcpSocket.recv(Buffer)</div><div class="line">		<span class="keyword">if</span> <span class="keyword">not</span> data:</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		tcpSocket.send(<span class="string">'[%s] %s'</span> % (ctime(),data))  <span class="comment">#返回消息</span></div><div class="line"></div><div class="line">	tcpClient.close()            <span class="comment">#关闭当前客户端连接</span></div><div class="line">tcpSocket.close()</div></pre></td></tr></table></figure>
<p><b>Tcp客户端代码:</b></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding=utf-8 -*-</span></div><div class="line"><span class="comment"># create Ttstcy</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">一个简单的TCP客户端</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">'''</span></div><div class="line">Host=<span class="string">'127.0.0.1'</span></div><div class="line">Port=<span class="number">56478</span></div><div class="line">Buffer=<span class="number">1024</span></div><div class="line">Add=(Host,Port)</div><div class="line"></div><div class="line">tcpClient=socket(AF_INET,SOCK_STREAM) <span class="comment">#建立socket套接字</span></div><div class="line">tcpClient.connect(Add)                <span class="comment">#连接服务器</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">	data= raw_input(<span class="string">'&gt; '</span>)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">not</span> data:</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	tcpClient.send(data)            <span class="comment">#向服务器发送数据</span></div><div class="line">	data=tcpClient.recv(Buffer)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">not</span> data:</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">print</span> data</div><div class="line"></div><div class="line">tcpClient.close()                 <span class="comment">#关闭客户端连接</span></div></pre></td></tr></table></figure>
<h4>2.采用SocketServer创建</h4>

<p><b>Tcp服务器代码:</b></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding=utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> SocketServer <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">简单的SocketServer Tcp服务器</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">'''</span></div><div class="line"></div><div class="line">Host=<span class="string">'127.0.0.1'</span></div><div class="line">Port=<span class="number">15489</span></div><div class="line">Add=(Host,Port)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequestHandler</span><span class="params">(StreamRequestHandler)</span>:</span> <span class="comment">#重写Handler方法</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">print</span> <span class="string">'connection from :'</span>,self.client_address</div><div class="line">		self.wfile(<span class="string">'[%s] %s'</span> % (ctime(),self.rfile.readline()))  <span class="comment">#wfile来发送data，readline()用来获取客户端date</span></div><div class="line"></div><div class="line">tcpServ = TCPServer(Add,MyRequestHandler)     </div><div class="line"><span class="keyword">print</span> <span class="string">'waiting for connection...'</span></div><div class="line">tcpServ.serve_forever()  <span class="comment">#无线循环请求</span></div></pre></td></tr></table></figure>
<p><b>TCP客户端:</b></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding=utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">SocketServer 客户端</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">'''</span></div><div class="line">Host=<span class="string">'127.0.0.1'</span></div><div class="line">Port=<span class="number">15489</span></div><div class="line">Buffer=<span class="number">1024</span></div><div class="line">Add=(Host,Port)</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">	tcpClient = socket(AF_INET,SOCK_STREAM)</div><div class="line">	tcpClient.connect(Add)</div><div class="line">	data= raw_input(<span class="string">'&gt;'</span>)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">not</span> data:</div><div class="line">		<span class="keyword">break</span></div><div class="line">	tcpClient.send(<span class="string">'%s\n'</span> % data)</div><div class="line">	data= tcpClient.recv(Buffer)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">not</span> data:</div><div class="line">		<span class="keyword">break</span></div><div class="line">	<span class="keyword">print</span> data</div><div class="line">	tcpClient.close()</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python排序算法03快速排序]]></title>
      <url>/2017/08/16/python%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9503%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3>快速排序</h3>

<h4>简述</h4>


<p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<h4>基本思想</h4>


<p>1.设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>2.以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>3.从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>4.从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>5.重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p>
<h4>代码实现</h4>

<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(array, left, right)</span>:</span></div><div class="line">    <span class="keyword">if</span> left &lt; right:</div><div class="line">        mid = partition(array, left, right)</div><div class="line">        quick_sort(array, left,  mid<span class="number">-1</span>)</div><div class="line">        quick_sort(array, mid+<span class="number">1</span>, right)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array, left, right)</span>:</span></div><div class="line">    tmp = array[left]</div><div class="line">    <span class="keyword">while</span> left &lt; right:</div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> array[right] &gt;= tmp:</div><div class="line">            right -= <span class="number">1</span></div><div class="line">        array[left] = array[right]</div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> array[left] &lt;= tmp:</div><div class="line">            left += <span class="number">1</span></div><div class="line">        array[right] = array[left]</div><div class="line">    array[left] = tmp</div><div class="line">    <span class="keyword">return</span> left</div></pre></td></tr></table></figure>
<h4>优缺点<4><br><br>优点:排序速度快<br>缺点:不稳定<br><br><br><h4>时间复杂度</h4>


<p>快速排序最优的情况下时间复杂度为：O( nlogn )<br>快速排序最差的情况下时间复杂度为：O( n^2 )</p>
</4></h4>]]></content>
      
        
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每天一道python练习05]]></title>
      <url>/2017/08/16/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93python%E7%BB%83%E4%B9%A005/</url>
      <content type="html"><![CDATA[<h3> 题目：对10个数进行排序</h3>

<p><b>code1:</b></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding=utf-8 -*-</span></div><div class="line"><span class="comment"># create Ttstcy</span></div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string"> 题目：对10个数进行排序</span></div><div class="line"><span class="string"> 直接调用排序方法sort()</span></div><div class="line"><span class="string">'''</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"please input 10 number:"</span></div><div class="line"></div><div class="line">arr=[]</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    l.append(int(raw_input(<span class="string">'Input you number:'</span>)))</div><div class="line"></div><div class="line">arr.sort()    <span class="comment">#直接调用sort()排序方法</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> arr</div></pre></td></tr></table></figure>
<p><b>code2:</b></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding=utf-8 -*-</span></div><div class="line"><span class="comment"># create Ttstcy</span></div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string"> 题目：对10个数进行排序</span></div><div class="line"><span class="string"> 采用排序算法</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">'''</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"please input 10 number:"</span></div><div class="line"></div><div class="line">arr=[]</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</div><div class="line">    arr.append(int(raw_input(<span class="string">'Input a number:'</span>)))</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):        <span class="comment">#编写排序算法</span></div><div class="line">     <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,<span class="number">10</span>):</div><div class="line">         <span class="keyword">if</span> l[j]&lt;l[i]:</div><div class="line">             temp = arr[j]</div><div class="line">             arr[j] = arr[i]</div><div class="line">             arr[i] = temp    </div><div class="line"></div><div class="line"><span class="keyword">print</span>  arr</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python排序算法02选择排序]]></title>
      <url>/2017/08/15/python%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9502%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p></p><h3>02选择排序</h3><br><b>描述</b><p></p>
<p>选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）<br>的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法<br>（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。</p>
<p><b>基本思想:</b><br>  对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置，接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了，然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。</p>
<p><b>代码如下:</b></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(lists)</span>:</span></div><div class="line">    <span class="comment"># 选择排序</span></div><div class="line">    count = len(lists)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, count):</div><div class="line">        min = i</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, count):</div><div class="line">            <span class="keyword">if</span> lists[min] &gt; lists[j]:</div><div class="line">                min = j</div><div class="line">        lists[min], lists[i] = lists[i], lists[min]</div><div class="line">    <span class="keyword">return</span> lists</div></pre></td></tr></table></figure>
<p> 优点：移动的数据次数已知为（n-1)次、<br> 缺点：不稳定、速度慢</p>
<p> <b>时间复杂度:</b></p>
<p> 选择排序的交换操作介于 0 和 (n - 1） 次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。<br> 选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。</p>
<p>  比较次数O(n^2），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+…+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。</p>
]]></content>
      
        
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每天一道python练习04]]></title>
      <url>/2017/08/15/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93python%E7%BB%83%E4%B9%A004/</url>
      <content type="html"><![CDATA[<h3>题目：输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。</h3>

<p>分析：控制语句进行判断。</p>
<p><b>code:</b></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding=utf-8 -*-</span></div><div class="line"><span class="comment"># create Ttstcy</span></div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">题目：输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">'''</span></div><div class="line"></div><div class="line">Intestr=raw_input(<span class="string">"请输入字符串："</span>)</div><div class="line"></div><div class="line">zm=<span class="number">0</span></div><div class="line">kg=<span class="number">0</span></div><div class="line">sz=<span class="number">0</span></div><div class="line">ot=<span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Intestr:</div><div class="line">	<span class="keyword">if</span> i.isalpha():</div><div class="line">		zm+=<span class="number">1</span></div><div class="line">	<span class="keyword">elif</span> i.isspace():</div><div class="line">		kg+=<span class="number">1</span></div><div class="line">	<span class="keyword">elif</span> i.isdigit():</div><div class="line">		sz+=<span class="number">1</span></div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		ot+=<span class="number">1</span></div><div class="line"><span class="keyword">print</span> (<span class="string">"字母有%d,空格有%d,数字有%d,其他有%d"</span>) % (zm,kg,sz,ot)</div></pre></td></tr></table></figure>
<p><b>注释：</b><br>i.isalnum() 所有字符都是数字或者字母<br>i.isalpha() 所有字符都是字母<br>i.isdigit() 所有字符都是数字<br>i.islower() 所有字符都是小写<br>i.isupper() 所有字符都是大写<br>i.istitle() 所有单词都是首字母大写，像标题<br>i.isspace() 所有字符都是空白字符、\t、\n、\r</p>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python排序算法01冒泡排序]]></title>
      <url>/2017/08/14/python%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9501%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3>01冒泡排序</h3>

<p><b>描述</b></p>
<p>  冒泡算法属于入门级算法，主要通过循环，进行向上的两两比较，从而达到冒泡的效果具体方法是针对循环中的每一元素，都对它后面的元素循环比较，交换大小值，每次循环“冒”一个最<br>大值（或最小值）放在里层循环初始的地方。<br>python中的具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment">#-* coding=utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">冒泡排序 for python</span></div><div class="line"><span class="string">'''</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(L)</span>:</span></div><div class="line">    <span class="keyword">assert</span>(type(L)==type([<span class="string">''</span>]))</div><div class="line">    length = len(L)</div><div class="line">    <span class="keyword">if</span> length==<span class="number">0</span> <span class="keyword">or</span> length==<span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> L</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(length):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(length<span class="number">-1</span>-i):</div><div class="line">            <span class="keyword">if</span> L[j] &lt; L[j+<span class="number">1</span>]: </div><div class="line">                temp = L[j]</div><div class="line">                L[j] = L[j+<span class="number">1</span>]</div><div class="line">                L[j+<span class="number">1</span>] = temp</div><div class="line">    <span class="keyword">return</span> L</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>冒泡优点： 稳定（时间复杂度为O(1)常量）、简单<br>       缺点：效率不高 （如果一个数组有n个数，那么排序完成后需要比较n*(n-1)/2次)</p>
]]></content>
      
        
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每天一道python练习03]]></title>
      <url>/2017/08/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93python%E7%BB%83%E4%B9%A003/</url>
      <content type="html"><![CDATA[<p></p><h3>题目：输入某年某月某日，判断这一天是这一年的第几天？</h3><br>strptime（）根据格式把字符串解析为一个元组<p></p>
<p>分析：通过datetime函数获取到当前时间转化为</p>
<p>code1:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment">#-*- coding:utf-8 -*-</span></div><div class="line"><span class="comment">#creat Ttstcy</span></div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">题目：输入某年某月某日，判断这一天是这一年的第几天？</span></div><div class="line"><span class="string">strptime（）根据格式把字符串解析为一个元组</span></div><div class="line"><span class="string">strftime() 函数接收以时间元组，并返回以可读字符串表示的当地时间，格式由参数format决定。</span></div><div class="line"><span class="string">'''</span></div><div class="line"></div><div class="line"><span class="comment">#导入时间的库函数</span></div><div class="line"><span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line">time=str(raw_input(<span class="string">"请输入日期(例如20170814):"</span>))</div><div class="line"></div><div class="line">tm=datetime.strptime(time,<span class="string">"%Y%m%d"</span>) <span class="comment">#现在日期</span></div><div class="line"></div><div class="line"></div><div class="line">tm1=time[<span class="number">0</span>:<span class="number">4</span>]+<span class="string">'0101'</span>         <span class="comment">#输入年限的第一天</span></div><div class="line">tm2=datetime.strptime(tm1,<span class="string">"%Y%m%d"</span>)   </div><div class="line"></div><div class="line">nowday=int((tm-tm2).days) + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"今天是今年的第%d天"</span> % nowday</div></pre></td></tr></table></figure></p>
<p>code2:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#导入时间的库函数</span></div><div class="line"><span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line">time=datetime.now()</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"今天是今年的第%s天"</span> % (time.strftime(<span class="string">"%j"</span>))</div></pre></td></tr></table></figure></p>
<p>注释:<br>python中时间日期格式化符号：<br>%y 两位数的年份表示（00-99）<br>%Y 四位数的年份表示（000-9999）<br>%m 月份（01-12）<br>%d 月内中的一天（0-31）<br>%H 24小时制小时数（0-23）<br>%I 12小时制小时数（01-12）<br>%M 分钟数（00=59）<br>%S 秒（00-59）<br>%a 本地简化星期名称<br>%A 本地完整星期名称<br>%b 本地简化的月份名称<br>%B 本地完整的月份名称<br>%c 本地相应的日期表示和时间表示<br>%j 年内的一天（001-366）<br>%p 本地A.M.或P.M.的等价符<br>%U 一年中的星期数（00-53）星期天为星期的开始<br>%w 星期（0-6），星期天为星期的开始<br>%W 一年中的星期数（00-53）星期一为星期的开始<br>%x 本地相应的日期表示<br>%X 本地相应的时间表示<br>%Z 当前时区的名称<br>%% %号本身</p>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每天一道python练习02]]></title>
      <url>/2017/08/13/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93python%E7%BB%83%E4%B9%A002/</url>
      <content type="html"><![CDATA[<h3>题目：一个整数，它加上100后是一个完全平方数，再加上168又是一个完全平方数，请问该数是多少？</h3>

<p>分析：可以通过math库里sqrt函数进行求解，如果可以开平方则这个数为整数，否则为浮点数。（math.sqrt()开方函数)</p>
<p>code:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment">#-*- coding:utf-8 -*-</span></div><div class="line"><span class="comment">#create Ttstcy</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line">i=<span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">if</span> math.sqrt(i+<span class="number">100</span>)-int(math.sqrt(i+<span class="number">100</span>))==<span class="number">0</span> <span class="keyword">and</span> math.sqrt(i+<span class="number">168</span>)-int(math.sqrt(i+<span class="number">168</span>))==<span class="number">0</span>:   </div><div class="line">        <span class="keyword">print</span> <span class="string">"这个数是%d"</span> % i</div><div class="line">        <span class="keyword">break</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        i+=<span class="number">1</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> python,math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每天一道python练习01]]></title>
      <url>/2017/08/12/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93python%E7%BB%83%E4%B9%A001/</url>
      <content type="html"><![CDATA[<h3>题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</h3>

<p>分析：可以采用 for循环排列由1234组成的三位数，用if条件进行不重复判断，最后输出。</p>
<p>code:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment">#-*- coding: utf-8 -*-</span></div><div class="line"><span class="comment">#create TTstcy</span></div><div class="line"><span class="comment">#计量次数</span></div><div class="line">num=<span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"由1234组成的不重复的三位数有:"</span></div><div class="line"></div><div class="line"><span class="comment">#for循环计算排列个数</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range（<span class="number">1</span>，<span class="number">5</span>):</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</div><div class="line">	    <span class="keyword">if</span> i!=j <span class="keyword">and</span> j!=k <span class="keyword">and</span> i!=k:</div><div class="line">	         <span class="keyword">print</span> i*<span class="number">100</span>+j*<span class="number">10</span>+k</div><div class="line">		 num+=<span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"共有%d种情况"</span> % num</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hello]]></title>
      <url>/2017/08/12/hello/</url>
      <content type="html"><![CDATA[<p>hello world!</p>
]]></content>
      
        
        <tags>
            
            <tag> hello </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
